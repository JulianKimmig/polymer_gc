from typing import List, Union, Optional, Dict, Tuple, Set
import numpy as np
from .datamodel import PolyGraph, PolyGraphEnsemble, Monomer
from .linear import make_linear_polymer_graphs
import networkx as nx


def make_branched_polymer_graphs(
    M: Union[float, List[float], np.ndarray],
    monomers: List[Monomer],
    branching_indices: List[int],  # Indices in the `monomers` list that can branch
    off_branches: List[
        int
    ],  # Corresponding number of branches allowed per branching monomer type
    n: int = 1,
    rel_content: Optional[List[List[float]]] = None,
    seed: Optional[int] = None,
    max_length: int = 400,
    **kwargs: Optional[Dict[str, Union[int, float, str]]],
) -> PolyGraphEnsemble:
    """
    Generates branched polymer graphs.

    First, linear polymers are generated. Then, for each linear polymer:
    1. Edges after monomers of a type specified in `branching_indices` are conceptually "broken".
    2. This divides the linear chain into several segments (subgraphs).
    3. One segment is chosen as the main backbone (seed).
    4. Other segments are iteratively attached as branches to available branching points
       on the growing structure. A branching point is a monomer whose type is in
       `branching_indices` and which has capacity (from `off_branches`) for more attachments.
    5. The attachment connects the designated "entry point" of the branch segment to the
       chosen branching point on the main structure.

    Args:
        M: Target mass(es) for the polymers.
        monomers: List of Monomer objects.
        branching_indices: List of indices into `monomers` specifying which monomer types are branchable.
        off_branches: List of integers, where `off_branches[i]` is the maximum number of
                      branches that can originate from a monomer of type `monomers[branching_indices[i]]`.
                      Must be same length as `branching_indices`.
        n: Number of polymers to generate if M is a float.
        rel_content: Relative content profiles for linear chain generation.
        seed: Random seed for reproducibility.
        max_length: Maximum length for the initial linear chain generation.

    Returns:
        PolyGraphEnsemble: An ensemble of generated branched polymer graphs.

    Raises:
        ValueError: If `branching_indices` and `off_branches` have different lengths,
                    or if branching is attempted on an empty graph or a graph too small to branch.
                    Also if not enough branching capacity is available to connect all segments.
    """
    if len(branching_indices) != len(off_branches):
        raise ValueError(
            "branching_indices and off_branches must have the same length."
        )

    branching_indices = np.array(branching_indices, dtype=int)
    n_monos = len(monomers)
    if kwargs.get("startgroup") is not None:
        n_monos += 1
        branching_indices += 1
    if kwargs.get("endgroup") is not None:
        n_monos += 1

    total_off_branches = np.ones(n_monos, dtype=int)
    total_off_branches[branching_indices] = off_branches

    # Initialize a main RNG for controlling seeds for sub-processes
    rng_main = np.random.default_rng(seed)

    lin_ensemble_seed = rng_main.integers(2**32)
    lin_ensemble = make_linear_polymer_graphs(
        M=M,
        monomers=monomers,
        n=n,
        rel_content=rel_content,
        seed=lin_ensemble_seed,  # Use a derived seed
        max_length=max_length,
        **kwargs,  # Pass any additional arguments to the linear polymer generation
        # Start/end groups are not explicitly handled by branching logic here,
        # but will be part of the linear chain if generated by make_linear_polymer_graphs.
        # If they are branchable, they should be in `monomers` and `branching_indices`.
    )

    branched_polygraphs: List[PolyGraph] = []

    for graph_idx, linear_graph in enumerate(lin_ensemble.graphs):
        graph_specific_seed = rng_main.integers(
            2**32
        )  # Seed for this specific graph's branching process
        rng_graph = np.random.default_rng(graph_specific_seed)

        lin_edges = linear_graph.edges
        lin_nodes = linear_graph.nodes

        split_n = int(
            1 + (len(lin_nodes) // (2 * (total_off_branches[lin_nodes] - 1).sum()))
        )

        # split every third edge
        temp_nx_graph = nx.Graph()
        temp_nx_graph.add_nodes_from(range(len(lin_nodes)))
        graph_available_off_branches = np.zeros(len(lin_nodes), dtype=int)
        graph_available_off_branches += total_off_branches[lin_nodes] - 1
        open_starts = []
        for i, e in enumerate(lin_edges):
            if i % split_n != 0 or i < split_n:
                temp_nx_graph.add_edge(e[0], e[1])
            else:
                open_starts.append(e[1])
                graph_available_off_branches[e[0]] += 1

        in_new_graph = np.zeros(len(graph_available_off_branches), dtype=bool)

        to_check = [lin_nodes[0]]
        while to_check:
            current_node = to_check.pop()
            if in_new_graph[current_node]:
                continue
            in_new_graph[current_node] = True
            for neighbor in temp_nx_graph.neighbors(current_node):
                if not in_new_graph[neighbor]:
                    to_check.append(neighbor)

        node_indices = np.arange(len(lin_nodes))

        while open_starts:
            next_start = open_starts.pop(0)

            props = (graph_available_off_branches * in_new_graph).astype(float)
            props /= props.sum()

            branch_point = rng_graph.choice(node_indices, p=props)

            temp_nx_graph.add_edge(branch_point, next_start)
            graph_available_off_branches[branch_point] -= 1

            to_check = [next_start]
            while to_check:
                current_node = to_check.pop()
                if in_new_graph[current_node]:
                    continue
                in_new_graph[current_node] = True
                for neighbor in temp_nx_graph.neighbors(current_node):
                    if not in_new_graph[neighbor]:
                        to_check.append(neighbor)

        branched_polygraphs.append(
            PolyGraph(
                nodes=lin_nodes,  # Node types remain the same, connectivity changes
                edges=temp_nx_graph.edges,
                monomers=lin_ensemble.monomers,
            )
        )

    return PolyGraphEnsemble(graphs=branched_polygraphs)
